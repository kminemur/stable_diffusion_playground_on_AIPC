## Repository Structure
```
multimodal_on_AIPC/
├── main.py                   # Uvicorn entrypoint that wires src/ into sys.path
├── download_models.py        # CLI helper to prefetch the OpenVINO snapshot
├── requirements.txt          # Python dependencies (FastAPI + OpenVINO stack)
├── src/app/
│   ├── __init__.py           # Exposes factory for external runners
│   ├── config.py             # Pydantic settings (dirs, device, repo id, toggles)
│   ├── main.py               # FastAPI factory, routes, static mounts
│   ├── models.py             # Request/response schemas + field validation
│   └── services.py           # Stable Diffusion service using OpenVINO pipeline
└── static/                   # Browser UI assets (HTML, JS, CSS, mock image)
```

Generated PNG files live under `data/generated/`, and downloaded model snapshots land in `data/models/stable-diffusion/`.

## Initialization Flow
1. `uvicorn main:app --reload` executes `main.py`, which ensures `src/` is importable and exposes the FastAPI app.
2. `src/app/main.py:create_app()` instantiates `Settings`, prepares cache directories, and builds a `StableDiffusionService`.
3. When `AUTO_DOWNLOAD_MODELS=true`, the service triggers `huggingface_hub.snapshot_download` to mirror `OpenVINO/stable-diffusion-v1-5-int8-ov` locally.
4. Static assets are mounted at `/static`, generated files at `/generated`, and REST routes are registered.

## Runtime Components
- **Settings (`config.py`)**  
  Parses environment variables via `pydantic-settings`. Controls mock mode, cache paths, Hugging Face repo, timeout, and target OpenVINO device (`GPU` by default).

- **StableDiffusionService (`services.py`)**  
  Wraps `OVStableDiffusionPipeline` from `optimum-intel`. Lazily loads the pipeline from the cached snapshot (or remote repo on first run), reshapes/compiles per resolution, and persists results. Includes a mock branch for deterministic responses without inference.

- **FastAPI App (`main.py`)**  
  Provides `/image` for generation and `/health` for readiness checks. Mounts static UI and generated-assets directories.

- **Frontend (`static/`)**  
  Minimal HTML/CSS/JS that posts prompts to `/image`, shows status updates, and displays the latest image. Uses fetch API directly—no build step required.

## Request Lifecycle
1. Browser submits a prompt via POST `/image` with parameters such as `prompt`, `width`, `height`, `guidance_scale`, etc.
2. Payload is validated by `ImageGenerationRequest`; width/height must be multiples of 8, ranges are enforced.
3. `StableDiffusionService.generate()` either returns a mock asset or runs the OpenVINO pipeline on the configured device (GPU with CPU fallback).
4. The generated PNG is stored under `data/generated/<job_id>.png`, and the API responds with metadata plus a `/generated/...` URL for the frontend.

## Health & Monitoring
- `/health` returns cache status, device target, mock state, and directories so operators can confirm readiness.
- Model compilation time for new resolutions is logged implicitly via the pipeline; consider wrapping with structured logging for more telemetry if needed.

## Configuration Surface (selected)
- `USE_MOCKS` — Enable deterministic placeholder responses.
- `AUTO_DOWNLOAD_MODELS` — Fetch the OpenVINO snapshot during startup.
- `MODELS_CACHE_DIR`, `GENERATED_IMAGES_DIR` — Override storage locations.
- `STABLE_DIFFUSION_REPO_ID` — Defaults to `OpenVINO/stable-diffusion-v1-5-int8-ov`.
- `OPENVINO_DEVICE` — Device string for inference (`GPU`, `CPU`, `AUTO`, etc.).
- `HUGGINGFACE_TOKEN` — Optional token for gated downloads.

## Operational Notes
- GPU execution assumes appropriate Intel GPU drivers. When unavailable, the service logs a warning and runs on CPU.
- `python download_models.py --force` wipes and re-downloads the snapshot (useful for CI or corrupted caches).
- Generated files are not rotated automatically; integrate `clean_generated_images()` or external housekeeping in production scenarios.

## Future Extensions
- Add authentication and rate limiting for multi-user setups.
- Introduce safety filters before persisting or returning images.
- Implement job queueing / background workers for longer-running tasks.
